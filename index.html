<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Jothy AdoreLife..</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="人生总是失去之后才懂得珍惜，时间总是被荒废之后才明白要抓牢">
<meta property="og:type" content="website">
<meta property="og:title" content="Jothy AdoreLife..">
<meta property="og:url" content="https://jothy1023.github.io/index.html">
<meta property="og:site_name" content="Jothy AdoreLife..">
<meta property="og:description" content="人生总是失去之后才懂得珍惜，时间总是被荒废之后才明白要抓牢">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jothy AdoreLife..">
<meta name="twitter:description" content="人生总是失去之后才懂得珍惜，时间总是被荒废之后才明白要抓牢">
  
    <link rel="alternative" href="/atom.xml" title="Jothy AdoreLife.." type="application/atom+xml">
  
  
    <link rel="icon" href="/assets/favicon.png">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="https://jothy1023.github.io/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">四月</a></h1>
		</hgroup>

		
		<p class="header-subtitle">人间四月芳菲尽，山寺桃花始盛开</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页菌</a></li>
	        
				<li><a href="/nodeJS">NodeJS</a></li>
	        
				<li><a href="/essay">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">Articles </a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)"> Tags </a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)"> Me</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/jothy1023" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/jothy1023" title="weibo">weibo</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">四月</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="https://jothy1023.github.io/avatar.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">四月</h1>
			</hgroup>
			
			<p class="header-subtitle">人间四月芳菲尽，山寺桃花始盛开</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页菌</a></li>
		        
					<li><a href="/nodeJS">NodeJS</a></li>
		        
					<li><a href="/essay">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/jothy1023" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/jothy1023" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-js-bind-es5-es6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/16/js-bind-es5-es6/">javascript 原生 bind() 的 ES6 + ES5 实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>前言： 本来只是想写一下简单的 bind 函数实现，没想到写着写着还能牵出 js 中继承的知识，其实研究原生函数的实现总是能学到很多新东西</p>
</blockquote>
<p>在实现之前呢，我们首先要知道 <code>bind</code> 是做什么的。JS MDN 给出的定义是 <em>The bind() methods creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called.</em> ，简单来说就是 <code>bind()</code> 函数创建了一个新函数（原函数的拷贝），这个函数接受一个提供新的 <code>this</code> 上下文的参数，以及之后任意可选的其他参数。当这个新函数被调用时，它的 <code>this</code> 关键字指向第一个参数的新上下文。而第二个之后的参数会与原函数的参数组成新参数（原函数的参数在后），传递给函数。  </p>
<p>弄清楚这个之后，我们再来分析看看要怎么做。  </p>
<p>首先，调用 bind() 会返回一个闭包，这个闭包中创建了一个新函数，这个函数首先包含原函数的属性与方法，并且这个函数的 this 值是传给 bind() 函数第一个参数，所以自然而然我们想到用 call 或者 apply 来改变原函数的 this ，这里我们选择 apply， 理由是我们新函数的第一个之后的参数是由传给 bind() 的第二个及之后的参数（代码中的 formerArgs ）再加上原函数的参数（代码中的 laterArgs ）构成的，我们把它们拼接成一个数组就完事儿了~具体代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">ctx</span>) </span>&#123;</div><div class="line">    <span class="comment">// 保存原函数的 this 至 _this</span></div><div class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span></div><div class="line">    <span class="comment">// slice 使用了两次，保存到变量中</span></div><div class="line">    <span class="comment">// slice 主要用于类数组对象 arguments 的浅复制</span></div><div class="line">    <span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice</div><div class="line">    <span class="comment">// 传给 bind() 函数的第二个至之后的参数，从  arguments 的第二位开始</span></div><div class="line">    <span class="keyword">var</span> formerArgs = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</div><div class="line"></div><div class="line">    <span class="comment">// bind() 本身就是一个函数，返回</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="comment">// 传给原函数的参数</span></div><div class="line">        <span class="keyword">let</span> laterArgs = slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>)</div><div class="line">        <span class="comment">// 返回一个函数，这个函数调用了原函数，并且 this 指向 bind 的第一个参数，</span></div><div class="line">        <span class="comment">// 第二个参数由 formerArgs  与 laterArgs组成 </span></div><div class="line">        <span class="keyword">return</span> _this.apply(ctx, formerArgs.concat(laterArgs))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="ES6-实现"><a href="#ES6-实现" class="headerlink" title="ES6 实现"></a>ES6 实现</h4><p>上面的代码是基于 ES5 实现的，当时对于不确定的参数的一般处理方法都是利用类数组对象 <code>arguments</code> （其中包含了传递给函数的所有参数），也就免不了使用 <code>call</code> 或者是 <code>apply</code> 对其进行数组操作。代码也就显得比较冗长。但是 ES6 不一样了呀~我们有了<strong>不定参数</strong>这个神器。无论有无参数，有几个参数都可以简单地处理。</p>
<blockquote>
<p>不定参数： 传递给函数的最后一个参数可以被标记为不定参数，当函数被调用时，不定参数之前的参数都可正常被填充，剩下的参数会被放进一个数组中，并被赋值给不定参数。而当没有剩下的参数时，不定参数会是一个空数组，而不会被填充为 <code>undefined</code> 。</p>
</blockquote>
<p>同样的功能，只要几行代码就可以实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// formerArgs 为传递给 bind 函数的第二个到之后的参数</span></div><div class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">ctx, ...formerArgs</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span></div><div class="line">    </div><div class="line">    <span class="comment">// laterArgs 为传递给原函数的参数</span></div><div class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...laterArgs</span>) =&gt;</span> &#123;</div><div class="line">        <span class="comment">// bind 函数的不定参数在原函数参数之前，formerArgs 本身就是数组，可以直接调用数组的 concat 方法，无需借助 call 或 apply</span></div><div class="line">        <span class="keyword">return</span> _this.apply(ctx, formerArgs.concat(laterArgs))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，我们就实现了简单的 bind() 函数的功能，接下来我们给它做点优化。</p>
<h4 id="优化-upupup"><a href="#优化-upupup" class="headerlink" title="优化 upupup.."></a>优化 upupup..</h4><ul>
<li>当 Function 的原型链上没有 bind 函数时，才加上此函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</div><div class="line">    <span class="comment">// add bind() to Function.prototype</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>只有函数才能调用 bind 函数，其他的对象不行。即判断 this 是否为函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</div><div class="line">    <span class="comment">// throw NOT_A_FUNCTION error</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>压轴戏： 关于继承</strong><br>我们上面的代码使用了借用 apply 继承的方式。用了 apply 来改变 this 的指向，继承了原函数的基本属性和引用属性，并且保留了可传参优点，但是新函数无法实现函数复用，每个新函数都会复制出一份新的原函数的函数，并且也无法继承到原函数通过 prototype 方式定义的方法或属性。<blockquote>
<p>为解决以上问题，我们选用 <strong>组合继承</strong> 方式，在使用 apply 继承的基础上，加上了原型链继承。<br>所以我们可以这么改。</p>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.binds) &#123;</div><div class="line">  <span class="built_in">Function</span>.prototype.binds = <span class="function"><span class="keyword">function</span> (<span class="params">ctx</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"NOT_A_FUNCTION -- this is not callable"</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span></div><div class="line">    <span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice</div><div class="line">    <span class="keyword">var</span> formerArgs = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</div><div class="line">    <span class="comment">// 定义一个中间函数，用于作为继承的中间值</span></div><div class="line">    <span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">let</span> laterArgs = slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>)</div><div class="line">      <span class="keyword">return</span> _this.apply(ctx, formerArgs.concat(laterArgs))</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 先让 fun 的原型方法指向 _this 即原函数的原型方法，继承 _this 的属性</span></div><div class="line">    fun.prototype = _this.prototype</div><div class="line">    <span class="comment">// 再将 fBound 即要返回的新函数的原型方法指向 fun 的实例化对象</span></div><div class="line">    <span class="comment">// 这样，既能让 fBound 继承 _this 的属性，在修改其原型链时，又不会影响到 _this 的原型链</span></div><div class="line">    fBound.prototype = <span class="keyword">new</span> fun()</div><div class="line"></div><div class="line">    <span class="keyword">return</span> fBound</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的代码中，我们引入了一个新的函数 fun，用于继承原函数的原型，并通过 new 操作符实例化出它的实例对象，供 fBound 的原型继承，至此，我们既让新函数继承了原函数的所有属性与方法，又保证了不会因为其对原型链的操作影响到原函数。用图来表示应该是下面这样的：</p>
<p><img src="http://note.youdao.com/yws/public/resource/80df4dc9bc62843524147237b56b847e/xmlnote/115F6B5CD1A74571A185AECF18F957EA/153" alt="image"></p>
<p>这样我们对新函数的 prototype 修改只会应用在它自己身上，而不会影响到原函数。</p>
<ul>
<li>其他<br>MDN 中还提到，若是将 bind 绑定之后的函数当作构造函数，通过 new 操作符使用，则不绑定传入的 this，而是将 this 指向实例化出来的对象。所以我们最终的代码为：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.binds) &#123;</div><div class="line">  <span class="built_in">Function</span>.prototype.binds = <span class="function"><span class="keyword">function</span> (<span class="params">ctx</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"NOT_A_FUNCTION -- this is not callable"</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span></div><div class="line">    <span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice</div><div class="line">    <span class="keyword">var</span> formerArgs = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</div><div class="line">    <span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">let</span> laterArgs = slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>)</div><div class="line">      <span class="comment">// 若通过 new 调用 bind() 之后的函数，则这时候 fBound 的 this 指向的是 fBound 实例，</span></div><div class="line">      <span class="comment">// 而下面又定义了 fBound 是 fun 的派生类（其 prototype 指向 fun 的实例），</span></div><div class="line">      <span class="comment">// 所以 this instanceof fun === true ，这时 this 指向了 fBound 实例，不另外绑定！</span></div><div class="line">      <span class="keyword">return</span> _this.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fun ? <span class="keyword">this</span> : ctx || <span class="keyword">this</span>, formerArgs.concat(laterArgs))</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fun.prototype = _this.prototype</div><div class="line">    fBound.prototype = <span class="keyword">new</span> fun()</div><div class="line"></div><div class="line">    <span class="keyword">return</span> fBound</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打完收工~~欧耶 ( •̀ ω •́ )y</p>
<blockquote>
<p>P.S: ES7 中已经淘汰了 .bind 的写法，而是使用两个冒号的方式 :: 来代替，（要不要这么可爱！不过呢，人家还只是个提案而已，到时候会不会被采用还不一定的呢</p>
</blockquote>
<p>用法有两种，第一种  <code>::对象.方法名</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">val</span>: <span class="string">'value'</span>,</div><div class="line">  <span class="attr">method</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.val)</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// ::对象.方法名</span></div><div class="line"><span class="comment">// 等价于 obj.method.bind(obj)</span></div><div class="line"><span class="comment">// 将 method 的 this 绑定为 obj </span></div><div class="line"><span class="comment">// 这里的 method 必须是 obj 的方法</span></div><div class="line">::obj.method;</div><div class="line"></div><div class="line"><span class="comment">// call</span></div><div class="line">obj.method(); <span class="comment">// value</span></div></pre></td></tr></table></figure>
<p>第二种， <code>对象::方法名()</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">val</span>: <span class="string">'value'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">method</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.val);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 对象::方法名() </span></div><div class="line"><span class="comment">// 等价于 method.call(obj) 或 method.apply(obj)</span></div><div class="line"><span class="comment">// 会直接调用并输出 'value'</span></div><div class="line"><span class="comment">// obj::method();</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 对象::方法  （无括号</span></div><div class="line"><span class="comment">// 等价于 method.bind(obj)</span></div><div class="line"><span class="comment">// 不会自动执行，必须赋值给 method 才能实现绑定</span></div><div class="line"><span class="comment">// 手动调用 method ，输出 vaue</span></div><div class="line">method = obj::method;</div><div class="line">method();</div></pre></td></tr></table></figure>
<p>嘛~ 有说的不对的地方，欢迎指正..</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/16/js-bind-es5-es6/" class="archive-article-date">
  	<time datetime="2016-10-16T12:19:06.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-16</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ECMAScript/">ECMAScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/bind/">bind</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es2015/">es2015</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es7/">es7</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-index" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/05/index/">Vuex 入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Vuex-是一个专门为-Vue-js-应用所设计的集中式状态管理架构"><a href="#Vuex-是一个专门为-Vue-js-应用所设计的集中式状态管理架构" class="headerlink" title="Vuex 是一个专门为 Vue.js 应用所设计的集中式状态管理架构 ."></a>Vuex 是一个专门为 Vue.js 应用所设计的集中式状态管理架构 .</h3><p>背景：小型应用里的每个组件维护着自有的状态，即当前应用的状态的一部分，所以整个应用的状态被分散在了各个角落，但是我们经常遇到要把<strong>状态的一部分</strong>共享给多个组件的情况。</p>
<blockquote>
<p>状态其实可以形象地想成我们的 data 里面的各个属性。</p>
</blockquote>
<hr>
<h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>Vuex 使用了单状态树（single state tree），一个 store 对象就存储了整个应用层的状态。它让我们可以更方便地定位某一具体的状态，并且在调试时能简单地获取到当前整个应用的快照。 </p>
<ul>
<li>先埋个伏笔。Vuex 使用的这种 single state tree 与 modularity 模块化是不冲突的，问题是，如何将 state 与 mutation 分到子模块中？</li>
<li>要使用 store ，首先必须<code>Vue.user(Vuex)</code>，然后将 store <code>const store = new Vuex.store()</code> inject 定义到 Vue 实例 app 中<code>new Vue({store})</code>，实现从根组件注入到所有子组件中，接着就可以在子组件中使用 <code>this.$store</code> 调用了。</li>
<li>当一个组件需要使用多个某 store 的状态属性或 getters ，可以使用 shared helper —— 共享帮手 <code>mapState</code>，它会返回一个对象 。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'helper: mapState (object)'</span>, () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">    <span class="attr">state</span>: &#123;</div><div class="line">      <span class="attr">a</span>: <span class="number">1</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getters</span>: &#123;</div><div class="line">      <span class="attr">b</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">2</span></div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">    store,</div><div class="line">    <span class="attr">computed</span>: mapState(&#123;</div><div class="line">      <span class="comment">// 在 mapState 里面我们既可以调用 store 的 state ，也可以调用 store 的 getters</span></div><div class="line">      a: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> state.a + getters.b</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">  expect(vm.a).toBe(<span class="number">3</span>)</div><div class="line">  store.state.a++</div><div class="line">  expect(vm.a).toBe(<span class="number">4</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>那么如何将它与本地的计算属性结合使用呢？一般我们会使用一个工具，将多个对象合而为一，再把这个最终的对象传递给 computed。但是这里我们可以直接使用 es6 的 stage 3 的 object spread operator —— 对象扩展操作符，来超简洁地实现这一功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">  localComputed () &#123;&#125;</div><div class="line">  <span class="comment">// 将其中的属性与本地的计算属性合并在一起</span></div><div class="line">  ...mapState(&#123;</div><div class="line">    <span class="attr">message</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.obj.message</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h4><p>  有时候我们需要从 store 的状态派生出其他状态，然后对这个状态（的方法）在多个组件中加以利用。通常我们的做法是复制这个方法，或者将它封装为一个公用的方法，然后在需要的时候导入，但是两者其实都不甚理想。Vuex 提供了 getters 属性，用途类似 stores 中的计算属性。<br>  getters 中的方法接受两个参数，分别为 state 以及 getters（其他 getters），用法如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">getters: &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  doneTodosCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> getters.doneTodos.length</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么我们在其他组件内部使用 getters 也变得十分简单</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">  doneTodosCount () &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doneTodosCount</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>mapGetters<br>可以将 store 的 getters 映射到本地的计算属性中来，除了可以使用数组之外，还可以使用对象起别名。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">...mapGetters([</div><div class="line">  <span class="string">'doneTodosCount'</span>,</div><div class="line">  <span class="string">'anotherGetter'</span>,</div><div class="line">  <span class="comment">// ...</span></div><div class="line">])</div></pre></td></tr></table></figure>
<hr>
<h4 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h4><p>能改变 Vuex store 中的 state 状态的唯一方法是提交 mutation 变更。mutation 和事件很像：都有字符串类型的 type 以及 handler 句柄。我们在 handler 中实际修改 state，state 为每个 mutation 的第一个参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="attr">state</span>: &#123;</div><div class="line">    <span class="attr">count</span>: <span class="number">1</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123;</div><div class="line">    increment (state) &#123;</div><div class="line">      <span class="comment">// mutate state</span></div><div class="line">      state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// call， 只有在使用 type increment 调用 mutation 时才能称为 handler</span></div><div class="line">store.commit(<span class="string">'increment'</span>)</div></pre></td></tr></table></figure>
<p>commit 的第二个可选参数为 payload 有效载荷，可以为普通类型或对象类型等等。<br>commit 方法还可以通过对象形式调用，这种情况下，这个对象都会被当成 payload 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">store.commit(&#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">'increment'</span>,</div><div class="line">  <span class="attr">amount</span>: <span class="number">10</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>little tips</li>
</ul>
<ul>
<li>建议使用大写命名 Mutation<br>将所有大写变量存放在一个文件中，需要的时候引入。使用 es6 的计算属性名新特性来使用常量作为方法名。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// mutation-types.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> SOME_MUTATION = <span class="string">'SOME_MUTATION'</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// store.js</span></div><div class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"><span class="keyword">import</span> &#123; SOME_MUTATION &#125; <span class="keyword">from</span> <span class="string">'./mutation-types'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="attr">state</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123;</div><div class="line">    <span class="comment">// we can use the ES2015 computed property name feature</span></div><div class="line">    <span class="comment">// to use a constant as the function name</span></div><div class="line">    [SOME_MUTATION] (state) &#123;</div><div class="line">      <span class="comment">// mutate state</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<blockquote>
<p>es6 计算属性名</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// e.g: 使用含有空格的变量作为属性名会报错，此时可以将它存为字符串或者存在中括号包裹的变量中</span></div><div class="line"><span class="keyword">var</span> lastName = <span class="string">"last name"</span>;</div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="string">"first name"</span>: <span class="string">"Nicholas"</span>,</div><div class="line">    <span class="comment">// 中括号包裹的变量</span></div><div class="line">    [lastName]: <span class="string">"Zakas"</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(person[<span class="string">"last name"</span>]); <span class="comment">// Zakas</span></div></pre></td></tr></table></figure>
<ul>
<li>mutations 必须都是同步的，它的改变必须在调用之后立即执行<br>因为它是唯一可以修改 state 的，如果它使用了异步方法，将会使我们的 state 变得无法追踪，定位问题也变得是否困难</li>
<li>在组件中 commit mutation 时<br>可以使用 this.$store.commit() 或者使用 mapMutations 方法，后者可以将组件中的方法映射到 store.commit 调用（需要在根组件注入 store）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  methods: &#123;</div><div class="line">    <span class="comment">// 传入数组</span></div><div class="line">    ...mapMutations([</div><div class="line">      <span class="string">'increment'</span> <span class="comment">// map this.increment() to this.$store.commit('increment')</span></div><div class="line">    ]),</div><div class="line">    <span class="comment">// 传入对象，可以使用 alias</span></div><div class="line">    ...mapMutations(&#123;</div><div class="line">      <span class="attr">add</span>: <span class="string">'increment'</span> <span class="comment">// map this.add() to this.$store.commit('increment')</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h4><p>actions 是提交 mutations 的，它可以有任意的异步操作。<br>actions 的第一个参数是 context，它向外暴露一组与 store 实例相同的方法/属性，所以可以直接调用 context.commit 或者访问 context.state 或者 context.getters 。我们通常使用 es6 的参数解构来简化我们的代码，直接写成 <code>{ commit }</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">  increment (&#123; commit &#125;) &#123;</div><div class="line">    commit(<span class="string">'increment'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如何触发 Actions？<br>actions 通过<code>store.dispatch(&#39;actionName&#39;)</code> 触发，其方法体中再触发 mutation，但是 mutations 是可以直接通过 store.commit 触发的，那么为什么不直接使用 store.commit(‘mutationName’) 呢？因为，actions 是可以异步执行的，而 mutations 只可以同步。所以这种 dispatch 调用可以在 action 内执行异步操作，也就是说可以执行异步 mutation。</li>
</ul>
<ul>
<li>可以使用 payload 格式或者对象形式触发。二者等价</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// dispatch with a payload</span></div><div class="line">store.dispatch(<span class="string">'incrementAsync'</span>, &#123;</div><div class="line">  <span class="attr">amount</span>: <span class="number">10</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// dispatch with an object</span></div><div class="line">store.dispatch(&#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">'incrementAsync'</span>,</div><div class="line">  <span class="attr">amount</span>: <span class="number">10</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>shopping cart 中的实际应用，既调用了异步 API，又提交了多个 mutation。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">  checkout (&#123; commit, state &#125;, payload) &#123;</div><div class="line">    <span class="comment">// save the items currently in the cart</span></div><div class="line">    <span class="keyword">const</span> savedCartItems = [...state.cart.added]</div><div class="line">    <span class="comment">// send out checkout request, and optimistically</span></div><div class="line">    <span class="comment">// clear the cart</span></div><div class="line">    commit(types.CHECKOUT_REQUEST)</div><div class="line">    <span class="comment">// the 异步 shop API accepts a success callback and a failure callback</span></div><div class="line">    shop.buyProducts(</div><div class="line">      products,</div><div class="line">      <span class="comment">// handle success</span></div><div class="line">      () =&gt; commit(types.CHECKOUT_SUCCESS),</div><div class="line">      <span class="comment">// handle failure</span></div><div class="line">      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在组件中分发 Actions<br>可以使用 <code>this.$store.dispatch()</code> 或者 <code>mapActions</code> 映射组件方法到 <code>store.dispatch</code> 中调用（需要注入 root）。同 <code>mapMutations</code></li>
<li>Actions 组合，怎么控制 actions 执行呢？<br>由于 actions 是异步的，因此我们就很难知道一个 action 什么时候完成，以及该怎么把多个 action 组合起来，处理复杂的异步工作流？<br>好在， <code>store.dispatch()</code> 方法返回了我们定义的 action handler 的返回值，所以我们可以直接返回一个 Promise 呀~</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">  actionA (&#123; commit &#125;) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        commit(<span class="string">'someMutation'</span>)</div><div class="line">        resolve()</div><div class="line">      &#125;, <span class="number">1000</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以这么用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>然后在另一个 action 中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</div><div class="line">    <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      commit(<span class="string">'someOtherMutation'</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h4><p>由于 Vuex 使用了单状态树，所以随着我们应用的规模逐渐增大， store 也越来越膨胀。为了应对这个问题，Vuex 允许我们将 store 分成多个 modules。每个 module 有着自己的 state, mutations, actions, getters, 甚至可以有嵌套（ nested ）的 modules。比如说：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  <span class="attr">state</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">getters</span>: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> moduleB = &#123;</div><div class="line">  <span class="attr">state</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">actions</span>: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="attr">modules</span>: &#123;</div><div class="line">    <span class="attr">a</span>: moduleA,</div><div class="line">    <span class="attr">b</span>: moduleB</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 注意，调用的时候，多个模块都在 state 对象中，而非 modules 中</span></div><div class="line">store.state.a <span class="comment">// -&gt; moduleA's state</span></div><div class="line">store.state.b <span class="comment">// -&gt; moduleB's state</span></div></pre></td></tr></table></figure>
<ul>
<li>modules 中的各种 state ， local or root？<ul>
<li>mutations 和 getters 中，接受的第一个参数是 modules 的本地 state</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  <span class="attr">state</span>: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123;</div><div class="line">    <span class="attr">increment</span>: (state) &#123;</div><div class="line">      <span class="comment">// state is the local module state</span></div><div class="line">      state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">getters</span>: &#123;</div><div class="line">    doubleCount (state) &#123;</div><div class="line">      <span class="keyword">return</span> state.count * <span class="number">2</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li></li>
</ul>
<ul>
<li>相似地，在 actions 中，<code>context.state</code> 为本地 state，而 <code>context.rootState</code> 为根 state</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  actions: &#123;</div><div class="line">    incrementIfOdd (&#123; state, commit &#125;) &#123;</div><div class="line">      <span class="keyword">if</span> (state.count % <span class="number">2</span> === <span class="number">1</span>) &#123;</div><div class="line">        commit(<span class="string">'increment'</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li></li>
</ul>
<ul>
<li>getters 的第三个参数才是 root state</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  getters: &#123;</div><div class="line">    sumWithRootCount (state, getters, rootState) &#123;</div><div class="line">      <span class="keyword">return</span> state.count + rootState.count</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="Strict-Mode-amp-Form-Handling"><a href="#Strict-Mode-amp-Form-Handling" class="headerlink" title="Strict Mode &amp; Form Handling"></a>Strict Mode &amp; Form Handling</h4><p>严格模式下，如果在 mutation handler 之外修改了 Vuex 的 state，应用就会抛错。比如我们将 Vuex 中的某个数据，用 Vue 的 v-model 绑定到 input 时，一旦感应到 input 改动，就会尝试去直接修改这个数据，严格模式下就会报错。所以建议是绑定 value 值，然后在 input 时调用 action 。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">"message"</span> @<span class="attr">input</span>=<span class="string">"updateMessage"</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line">computed: &#123;</div><div class="line">  ...mapState(&#123;</div><div class="line">    <span class="attr">message</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.obj.message</div><div class="line">  &#125;)</div><div class="line">&#125;,</div><div class="line"><span class="attr">methods</span>: &#123;</div><div class="line">  updateMessage (e) &#123;</div><div class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'updateMessage'</span>, e.target.value)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>mutation 可以这么处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mutations: &#123;</div><div class="line">  updateMessage (state, message) &#123;</div><div class="line">    state.obj.message = message</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>诚然，这样做是很仔细明了的，但是我们也不能用 v-model 这么好用的方法了，另外一个方法就是继续使用 v-model ，并配套使用 双向计算属性和 setter 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">  <span class="attr">message</span>: &#123;</div><div class="line">    get () &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.obj.message</div><div class="line">    &#125;,</div><div class="line">    set (value) &#123;</div><div class="line">      <span class="comment">// 直接 commit 到 mutation，type 为 updateMessage</span></div><div class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'updateMessage'</span>, value)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>建议部署到开发环境的时候一定一定要关掉严格模式。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/05/index/" class="archive-article-date">
  	<time datetime="2016-10-05T05:17:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-05</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/">Vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vuex/">Vuex</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/actions/">actions</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/getters/">getters</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/modules/">modules</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mutations/">mutations</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/state/">state</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/入门/">入门</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-vueList" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/13/vueList/">Vue 2.0 制作列表组件，实现分页、搜索、批量操作等</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文仅讲解如何使用 Vue 创建一个实现分页、搜索、批量操作的列表组件，所以只提供此小组件的代码及说明，不提供其之外的代码或配置</p>
</blockquote>
<h4 id="使用到的技术或框架"><a href="#使用到的技术或框架" class="headerlink" title="使用到的技术或框架"></a>使用到的技术或框架</h4><hr>
<ul>
<li><strong>Vue.js (2.0)</strong> 一套基于 MVVM 的 progressive framework，可以帮助我们迅速搭建用户界面</li>
<li><strong>semantic UI</strong> 一套漂亮的 UI 框架</li>
<li><strong>localStorage</strong> HTML5 的本地存储 API 之一（另一个为 sessionStorage），顾名思义， localStorage 保存在当前设备内存中，除非主动删除，否则一直存在</li>
</ul>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><hr>
<ul>
<li>安装 Vue 2.0 (rc.6)</li>
<li>引入 semantic.js 文件</li>
<li>创建 Audit.vue 文件</li>
</ul>
<h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><hr>
<p>一个简单的 Vue 组件由三部分组成：html 模板 、javascript 脚本 以及 css  样式。下面我们一一来看。<br>效果图如下：</p>
<p><img src="../../../../assets/pic1.png" alt="oops 图裂了.jpg"></p>
<p><img src="../../../../assets/pic2.png" alt="oops 图裂了.jpg"></p>
<p>用到的数据结构是一个简单的 user 对象数组，对象格式为<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">user &#123;</div><div class="line">  <span class="attr">id</span>: int</div><div class="line">  name: <span class="built_in">String</span>,</div><div class="line">  <span class="attr">audit</span>: int</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中 audit 用来标记是否审核成功，共 4 个状态从 0 到 3，分别为 未审核、正在审核、已审核、审核不通过。</p>
<h5 id="html-模板"><a href="#html-模板" class="headerlink" title="html 模板"></a>html 模板</h5><p>由一对<code>&lt;template&gt;&lt;/template&gt;</code>标签作为唯一父标签包裹住模板内容，模板内分为 filter （过滤）、container （主体）两部分。</p>
<h6 id="container"><a href="#container" class="headerlink" title="container"></a>container</h6><p>container 主体是一个 table 表格，表格内容 tbody 部分使用 Vue 的 v-for 指令，基于 users 数组渲染出列表。主要代码如下</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">"user in filteredUsers"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">"collapsing"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ui toggle slider checkbox"</span> <span class="attr">v-if</span>=<span class="string">"aKey!==''"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">:value</span>=<span class="string">"user"</span> <span class="attr">v-model</span>=<span class="string">"selectedUsers"</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user.id &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user.name &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"radio black icon"</span> <span class="attr">v-if</span>=<span class="string">"user.audit==0"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"minus blue icon"</span> <span class="attr">v-if</span>=<span class="string">"user.audit==1"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"checkmark green icon"</span> <span class="attr">v-if</span>=<span class="string">"user.audit==2"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"remove red icon"</span> <span class="attr">v-if</span>=<span class="string">"user.audit==3"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ui-button</span> <span class="attr">css</span>=<span class="string">"primary"</span> <span class="attr">v-if</span>=<span class="string">"user.audit==0"</span> @<span class="attr">click</span>=<span class="string">"user.audit=1"</span>&gt;</span>审核<span class="tag">&lt;/<span class="name">ui-button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ui-button</span> <span class="attr">css</span>=<span class="string">"green"</span> <span class="attr">v-if</span>=<span class="string">"user.audit==1"</span> @<span class="attr">click</span>=<span class="string">"user.audit=2"</span>&gt;</span>通过审核<span class="tag">&lt;/<span class="name">ui-button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ui-button</span> <span class="attr">css</span>=<span class="string">"red"</span> <span class="attr">v-if</span>=<span class="string">"user.audit==1"</span> @<span class="attr">click</span>=<span class="string">"user.audit=3"</span>&gt;</span>不通过审核<span class="tag">&lt;/<span class="name">ui-button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ui-button</span> <span class="attr">css</span>=<span class="string">"grey"</span> <span class="attr">v-if</span>=<span class="string">"user.audit==2 || user.audit==3"</span> @<span class="attr">click</span>=<span class="string">"user.audit=1"</span>&gt;</span>再次审核<span class="tag">&lt;/<span class="name">ui-button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div></pre></td></tr></table></figure>
<p>其中，<code>filteredUsers</code> 为计算属性 computed 的一个 getter，用于从模板中分理出较复杂的逻辑，此处返回过滤后的 users 。<br>下来有一个 type 为 checkbox 的 input，当按照某一审核要求过滤时显示，其 v-model 指向 selectedUsers 数组，用来保存批量操作中选中的 user ，之后可以直接对此数组进行操作，改动会同步到 users 。</p>
<h6 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h6><p>filter 部分由一个 input 输入框以及一个 select 选择框组成，分别可以通过用户名和审核状态过滤。具体代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"filter"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">ui-input</span> <span class="attr">css</span>=<span class="string">"icon"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"fKey"</span> <span class="attr">placeholder</span>=<span class="string">"输入姓名搜索.."</span> /&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"search icon"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">ui-input</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- dropdown --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">ui-dropdown</span> <span class="attr">:setting</span>=<span class="string">"&#123;allowAdditions: true&#125;"</span> <span class="attr">css</span>=<span class="string">"selection"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"aKey"</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">v-model.lazy</span>=<span class="string">"aKey"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"default text"</span>&gt;</span>Select a id<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"dropdown icon"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"menu"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span> <span class="attr">data-value</span>=<span class="string">""</span>&gt;</span>所有<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span> <span class="attr">data-value</span>=<span class="string">"0"</span>&gt;</span>未审核<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span> <span class="attr">data-value</span>=<span class="string">"1"</span>&gt;</span>正在审核<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span> <span class="attr">data-value</span>=<span class="string">"2"</span>&gt;</span>已审核<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span> <span class="attr">data-value</span>=<span class="string">"3"</span>&gt;</span>审核不通过<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">ui-dropdown</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>select 使用 semanticUI 的 dropdown 实现，将其 class 设置为 selection。 dropdown 中包含一个 input 标签，此标签属性为 <code>&lt;input name=&quot;aKey&quot; type=&quot;hidden&quot; v-model.lazy=&quot;aKey&quot;&gt;</code>，其中，name 对应 v-model 的属性名，负责将值从下面的 .item 中的 data-value 取回并传递。<br>此处有一个地方需要引起注意！！<strong>（敲黑板</strong><br>由于此处的 input 标签其实算是 select 组件的，改动时默认行为是 change 而非 input ，也没有输入框，因此就算添加了 v-model 也无法触发。但是添加 @change 却可以正常触发，百思不得姐，经过千难万苦跋山涉水之后，终于发现！！在 Vue 的源码中有这么一断代码：</p>
<p><img src="../../../../assets/pic3.png" alt="oops 图裂了.jpg"></p>
<p> 我们只关注首末行，噢.. 大意就是，判断有无 <strong>lazy</strong> 属性（或者在 IE 环境下并且类型为 range ），true 时监听 change 事件，否则监听 input 事件。真相大白啦，机智地给 v-model 加上个小尾巴 .lazy ，hot-loader 马上刷新，一试果然成功了！赞 b(￣▽￣)d<br>P.S: 后来又翻了翻 Vue 的教程，发现尤大大其实在教程中已经说明过了，惹..附图</p>
<p><img src="../../../../assets/pic4.png" alt="oops 图裂了.jpg"></p>
<p> 并且.. 1.0 版本与 2.0 版本也有点细微差别，1.0 是直接写在 input 标签的末尾，而 2.0 必须紧跟 v-model 之后。</p>
<p>当二者的 v-model 即 fKey 或 aKey 发生改变时，触发 computed 属性重新计算 filteredUsers ，重新渲染 users 列表，还有个 paginate 为分页方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">filteredUsers () &#123;</div><div class="line">  <span class="keyword">let</span> fUsers = <span class="keyword">this</span>.queryFilter(<span class="string">'name'</span>, <span class="keyword">this</span>.fKey, <span class="keyword">this</span>.users)</div><div class="line">  fUsers = <span class="keyword">this</span>.queryFilter(<span class="string">'audit'</span>, <span class="keyword">this</span>.aKey, fUsers)</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.paginate(fUsers)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="javascript-脚本"><a href="#javascript-脚本" class="headerlink" title="javascript 脚本"></a>javascript 脚本</h4><h6 id="初始数据"><a href="#初始数据" class="headerlink" title="初始数据"></a>初始数据</h6><p>定义了 initialUsers 数组，存进去若干个 user 对象，定义 userStorage 对象，存放 fetch 与 save 方法，分别调用 localStorage 的 getItem 与 setItem 方法向 localStorage 获取及存储数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> userStorage</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> STORAGE_KEY = <span class="string">'users'</span>;</div><div class="line"></div><div class="line">  userStorage = &#123;</div><div class="line">    <span class="attr">fetch</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(localStorage.getItem(STORAGE_KEY)) || initialUsers</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">save</span>: <span class="function"><span class="keyword">function</span> (<span class="params">users</span>) </span>&#123;</div><div class="line">      localStorage.setItem(STORAGE_KEY, <span class="built_in">JSON</span>.stringify(users))</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">init(<span class="built_in">window</span>);</div></pre></td></tr></table></figure></p>
<p>接着是 Vue 实例的各属性方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">data () &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">users</span>: userStorage.fetch(), <span class="comment">// users 数据</span></div><div class="line">    selectedUsers: [], <span class="comment">// 保存选中的 users 数组</span></div><div class="line">    fKey: <span class="string">''</span>, <span class="comment">// 过滤 name 的关键字</span></div><div class="line">    name: <span class="string">''</span>, <span class="comment">// 上一次过滤的 name 关键字，初始化为''</span></div><div class="line">    aKey: <span class="string">''</span>, <span class="comment">// select audit 的关键字</span></div><div class="line">    audit: <span class="string">''</span>, <span class="comment">// 上一次过滤的 audit关键字，初始化为''</span></div><div class="line">    limit: <span class="number">10</span>, <span class="comment">// 每页显示行数</span></div><div class="line">    totalPage: <span class="number">0</span>, <span class="comment">// 总页数</span></div><div class="line">    currentPage: <span class="number">0</span>, <span class="comment">// 当前页</span></div><div class="line">    jPage: <span class="number">1</span> <span class="comment">// 跳转到某页</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此处的 name 与 audit 看起来有些多余，其实它是有很重要的作用的，它用于保存上一次过滤的 key与 本次的对比。</p>
<h6 id="过滤方法-queryFilter"><a href="#过滤方法-queryFilter" class="headerlink" title="过滤方法 queryFilter"></a>过滤方法 queryFilter</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">queryFilter (prop, key, arr) &#123;</div><div class="line">  <span class="comment">// none query string, return arr</span></div><div class="line">  <span class="keyword">if</span> (!key) &#123;</div><div class="line">    <span class="keyword">return</span> arr</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// filtering</span></div><div class="line">  arr = arr.filter(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (user[prop].toString().indexOf(key) !== <span class="number">-1</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span> </div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  <span class="comment">// if it's a new filter query, refilter and turn to page one</span></div><div class="line">  <span class="keyword">if</span> (key !== <span class="keyword">this</span>[prop]) &#123;</div><div class="line">    <span class="keyword">this</span>.currentPage = <span class="number">0</span></div><div class="line">    <span class="comment">// save last filter query</span></div><div class="line">    <span class="keyword">this</span>[prop] = key</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> arr</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个设置应用情境是：未设置这个变量时，若用户在一次搜索之后进行翻页，假设停留在了第 n 页，这时候再重新搜索，页面会停留在本次搜索的结果的第 n 页，非常不方便。因此检测如果重新搜索，则充值 currentPage 属性，记录新的 key 。</p>
<h6 id="分页方法-paginate"><a href="#分页方法-paginate" class="headerlink" title="分页方法 paginate"></a>分页方法 paginate</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">paginate (arr) &#123;</div><div class="line">  <span class="keyword">this</span>.totalPage = <span class="built_in">Math</span>.ceil(arr.length / <span class="keyword">this</span>.limit)</div><div class="line">  <span class="keyword">let</span> page = <span class="keyword">this</span>.currentPage</div><div class="line">  <span class="keyword">let</span> curLimit = <span class="keyword">this</span>.limit</div><div class="line">  <span class="comment">// 返回指定条数的数组</span></div><div class="line">  arr = arr.slice(curLimit * page, curLimit * (page + <span class="number">1</span>))</div><div class="line">  <span class="keyword">return</span> arr</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此处用到了数组的 slice 方法进行浅复制。</p>
<h6 id="翻页方法-turnPage"><a href="#翻页方法-turnPage" class="headerlink" title="翻页方法 turnPage"></a>翻页方法 turnPage</h6><p>接受一个数组，1 为向后翻页，-1 为向前翻页</p>
<ul>
<li>HTML </li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"jtp"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>跳转到第 <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">ui-input</span> <span class="attr">css</span>=<span class="string">"icon"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"jPage"</span> @<span class="attr">keyup.enter</span>=<span class="string">"jumpToPage"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">ui-input</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> 页<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>Javascript</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">turnPage (num) &#123;</div><div class="line">  <span class="keyword">if</span> (num === <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentPage === <span class="keyword">this</span>.totalPage - <span class="number">1</span>) &#123;</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">this</span>.currentPage++</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentPage === <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">this</span>.currentPage--          </div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="单个操作修改-audit"><a href="#单个操作修改-audit" class="headerlink" title="单个操作修改 audit"></a>单个操作修改 audit</h6><p>为单独操作的 button 添加 @click 事件，直接修改</p>
<h6 id="批量操作方法"><a href="#批量操作方法" class="headerlink" title="批量操作方法"></a>批量操作方法</h6><p>由于 selectedUsers 数组保存了被选中 users 的数据，因此只要调用 setAuditId 方法，传入 selectedUsers 以及要设置的 audit ，遍历 selectedUsers 进行设置即可。代码举例如下：</p>
<ul>
<li>HTML </li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ui-button</span> <span class="attr">css</span>=<span class="string">"green"</span> <span class="attr">v-if</span>=<span class="string">"aKey==='1'"</span> @<span class="attr">click</span>=<span class="string">"pass"</span>&gt;</span>通过审核<span class="tag">&lt;/<span class="name">ui-button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ui-button</span> <span class="attr">css</span>=<span class="string">"red"</span> <span class="attr">v-if</span>=<span class="string">"aKey==='1'"</span> @<span class="attr">click</span>=<span class="string">"reject"</span>&gt;</span>不通过审核<span class="tag">&lt;/<span class="name">ui-button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ui-button</span> <span class="attr">css</span>=<span class="string">"small"</span> <span class="attr">v-if</span>=<span class="string">"aKey==='0'"</span> @<span class="attr">click</span>=<span class="string">"approveSel"</span>&gt;</span>审核<span class="tag">&lt;/<span class="name">ui-button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ui-button</span> <span class="attr">css</span>=<span class="string">"small"</span> <span class="attr">v-if</span>=<span class="string">"aKey==='0'"</span> @<span class="attr">click</span>=<span class="string">"approveAll"</span>&gt;</span>全部审核<span class="tag">&lt;/<span class="name">ui-button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ui-button</span> <span class="attr">css</span>=<span class="string">"small"</span> <span class="attr">v-if</span>=<span class="string">"aKey==='2' || aKey==='3'"</span> @<span class="attr">click</span>=<span class="string">"approveSel"</span>&gt;</span>再次审核<span class="tag">&lt;/<span class="name">ui-button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ui-button</span> <span class="attr">css</span>=<span class="string">"small"</span> <span class="attr">v-if</span>=<span class="string">"aKey==='2' || aKey==='3'"</span> @<span class="attr">click</span>=<span class="string">"approveAll"</span>&gt;</span>全部再次审核<span class="tag">&lt;/<span class="name">ui-button</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>Javascript</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">approveSel () &#123;</div><div class="line">  <span class="keyword">this</span>.setAuditId(<span class="keyword">this</span>.selectedUsers, <span class="number">1</span>)</div><div class="line">&#125;,</div><div class="line"></div><div class="line">approveAll () &#123;</div><div class="line">  <span class="keyword">this</span>.setAuditId(<span class="keyword">this</span>.filteredUsers, <span class="number">1</span>)</div><div class="line">&#125;,</div><div class="line"></div><div class="line">pass () &#123;</div><div class="line">  <span class="keyword">this</span>.setAuditId(<span class="keyword">this</span>.selectedUsers, <span class="number">2</span>)</div><div class="line">&#125;,</div><div class="line"></div><div class="line">reject () &#123;</div><div class="line">  <span class="keyword">this</span>.setAuditId(<span class="keyword">this</span>.selectedUsers, <span class="number">3</span>)</div><div class="line">&#125;,</div><div class="line"></div><div class="line">setAuditId (users, aId) &#123;</div><div class="line">  users.forEach(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</div><div class="line">    user.audit = aId</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此外，还添加了 watch 对 users 进行检测，每当其改变（例如 修改了 audit）时，将新的 users 存入 localStorage 中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// watch</span></div><div class="line">watch: &#123;</div><div class="line">  <span class="attr">users</span>: &#123;</div><div class="line">    handler () &#123;</div><div class="line">      userStorage.save(<span class="keyword">this</span>.users)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">deep</span>: <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h5><p>这部分其实没什么好说的，基本上都用了 semanticUI 的 css ，只在最后的跳转页码输入框的地方重设了 input 的大小而已。</p>
<p>至此，整个组件就完成啦~~撒花<em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em> 。<br>初试 Vue ，对一些 api 的使用可能有不准确的，有写得不好的地方欢迎指正。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/09/13/vueList/" class="archive-article-date">
  	<time datetime="2016-09-13T10:06:56.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-09-13</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/">Vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vuejs/">vuejs</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/全选/">全选</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分页/">分页</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/搜索/">搜索</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-thisInJS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/28/thisInJS/">javascript中函数的this指向以及apply/call/bind函数的联系与区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p>&emsp; 三者的联系就在于，都可以用来改变函数中 this 指向的值，且第一个参数为要指向的 this 的值，apply的第二个参数（或 bind 与 call 的不定参数）为要传入的参数。这就不得不提及 javascript 中函数的 this 的指向了。this 的指向大概有以下几种。</p>
<p>1.全局作用域下或正常的函数调用的 this<br>此时 this 指向的是全局对象。这时有两种情况，如果是在浏览器环境下运行，则 this 指向全局的 window 对象；而如果是在 nodejs 环境下执行，命令行中指向的是 global 对象。有一点需要注意的是，严格模式 “use strict” 下的 this 为 undefined 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 浏览器</span></div><div class="line"><span class="keyword">this</span>.a = <span class="number">10</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 10</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// nodejs</span></div><div class="line"><span class="keyword">this</span>.a = <span class="number">20</span>;</div><div class="line"><span class="built_in">console</span>.log(global.a); <span class="comment">// 20</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 非严格模式</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(f1() === <span class="built_in">window</span>); <span class="comment">// 浏览器 true</span></div><div class="line"><span class="built_in">console</span>.log(f1() === global); <span class="comment">// nodejs true</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 严格模式下</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">  "use strict"</span>;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(f2() === <span class="literal">undefined</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>2.当函数作为某对象的方法被调用时<br> this 指向的是调用该函数的对象，以下代码指的是对象 a。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">  <span class="attr">b</span>: <span class="number">30</span>,</div><div class="line">  <span class="attr">c</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.b);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">a.c(); <span class="comment">// 30</span></div></pre></td></tr></table></figure>
<p>3.构造器函数调用<br>以构造器函数的形式声明函数，再用 new 关键字声明一个新的函数对象，此时函数中的 this 指向这个构造出来的对象。在 jslint 比较严格的要求下，这种构造函数的函数名必须是首字母大写的形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.b = <span class="number">40</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> A();</div><div class="line"><span class="built_in">console</span>.log(obj.b); <span class="comment">// 40</span></div></pre></td></tr></table></figure>
<p>4.利用 apply/call/bind 方法强制改变 this 的指向<br>这时可以将要指向的对象 O 作为第一个参数传给以上任意三个函数之一，用某 F 函数调用这三个函数，这样 F 函数中的所有 this 的指向就都变成了对象 O，并且此时 O 就算没有声明 F 函数中的方法，也可以正常调用 F 函数中的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.b + arg);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">b</span> : <span class="number">1</span></div><div class="line">&#125;;</div><div class="line">a(); <span class="comment">// NaN</span></div><div class="line">a.apply(obj, [<span class="number">50</span>]); <span class="comment">// 51</span></div><div class="line">a.call(obj, <span class="number">60</span>); <span class="comment">// 61</span></div><div class="line"><span class="keyword">var</span> c = a.bind(obj, <span class="number">70</span>);</div><div class="line">c(); <span class="comment">// 71</span></div></pre></td></tr></table></figure>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>其实区别从上面的第四种也可见一斑。</p>
<ol>
<li>apply 与 call： 第二个参数的形式 apply 为数组形式，函数会自动帮我们把数组展开，而 call 与 bind 为不定参数，需要传递几个就传递几个。</li>
<li>bind 与 （apply 和 call）：apply 与 call 都是在被调用的时候就执行函数体内容，而 bind 绑定之后返回绑定完成的函数，需要再显式执行一次此函数才能完成调用。</li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/07/28/thisInJS/" class="archive-article-date">
  	<time datetime="2016-07-28T02:36:09.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-07-28</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/apply/">apply</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/bind/">bind</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/call/">call</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nodejs/">nodejs</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/this/">this</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-underscoreSourceCode" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/13/underscoreSourceCode/">underscore源码解析之类型判断函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;首先将内置对象的原型链以及内置对象原型中的常用方法缓存在局部变量中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 内置对象原型链</span></div><div class="line"><span class="keyword">var</span> ArrayProto = <span class="built_in">Array</span>.prototype,</div><div class="line">    ObjProto = <span class="built_in">Object</span>.prototype,</div><div class="line">    FuncProto = <span class="built_in">Function</span>.prototype;</div><div class="line"></div><div class="line"><span class="comment">// 内置对象原型中的常用方法 e.g: toString</span></div><div class="line"><span class="keyword">var</span> toString = ObjProto.toString,</div><div class="line">    hasOwnProperty = ObjProto.hasOwnProperty;</div></pre></td></tr></table></figure>
<p>&emsp;这样做的好处除了简洁代码之外，还有两个好处，首先是利于代码的压缩。而原生的对象原型无法进行压缩，e.g: Object.Protype压缩之后宿主就不认识了，但是objProto可以压缩为a，之后的调用也可以正常进行；然后是可减少在原型链中的查找次数(提高代码效率)。</p>
<hr>
<p>&emsp;再定义一组javascript原生支持的判断函数，若宿主环境（浏览器/nodejs）支持，则直接返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> nativeIsArray      = <span class="built_in">Array</span>.isArray,</div><div class="line">    nativeKeys         = <span class="built_in">Object</span>.keys,</div><div class="line">    nativeBind         = FuncProto.bind,</div><div class="line">    nativeCreate       = <span class="built_in">Object</span>.create;</div></pre></td></tr></table></figure>
<p>&emsp;若不支持以上函数（es5之后才支持），则返回underscore自己写的判断函数。</p>
<hr>
<ul>
<li>是否为DOM</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_.isElement = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="comment">// 首先确保不是 null/undefined 等假值（!!obj），</span></div><div class="line">  <span class="comment">// DOM 的 nodeType 为1，!!用于强制类型转换为 Boolean 值</span></div><div class="line">  <span class="keyword">return</span> !!(obj &amp;&amp; obj.nodeType === <span class="number">1</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>是否为数组Array</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_.isArray = nativeIsArray || <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="comment">// call 方法可以使得任意 obj 都可以调用 toString 方法，即使是没有 toString 方法的对象</span></div><div class="line">  <span class="keyword">return</span> toString.call(obj) === <span class="string">'[object aray]'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>是否为对象Object</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">_.isObject = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> type = <span class="keyword">typeof</span>(obj);</div><div class="line">  <span class="comment">// 除了普通对象之外，函数也是对象</span></div><div class="line">  <span class="comment">// !!obj 是为了排除 null 的情况，因为 typeof null 也为 object</span></div><div class="line">  <span class="keyword">return</span> type === <span class="string">'function'</span> || type === <span class="string">'object'</span> &amp;&amp; !!obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>是否为布尔值Boolean</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_.isBoolean = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="comment">// 除了 true 与 false 之外，布尔值还可能是 new Boolean() 哦</span></div><div class="line">  <span class="comment">// 不过似乎直接用最后一种判断就可以了？</span></div><div class="line">  <span class="keyword">return</span> obj === <span class="string">'true'</span> || obj === <span class="string">'false'</span> || toString.call(obj) === <span class="string">'[object boolean]'</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>是否为arguments</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!_.isArguments(<span class="built_in">arguments</span>)) &#123;</div><div class="line">  _.isArguments = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="comment">// 通过是否有 callee 方法判断</span></div><div class="line">    <span class="comment">// 因为IE &lt; 9 下对 arguments 调用 Object.prototype.toString.call 方法</span></div><div class="line">    <span class="comment">// 返回的是 [object Object] ，而非 [object Arguments]</span></div><div class="line">    <span class="keyword">return</span> _.has(obj, <span class="string">'callee'</span>);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>是否为NaN</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">_.isNaN = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="comment">// NaN是一个Number类型，但是它不等于它本身</span></div><div class="line">  <span class="comment">// ‘+’ 放在变量前面一般作用是把后面的变量变成一个数，</span></div><div class="line">  <span class="comment">// 在这里已经判断为一个数仍加上 ‘+’，是为了把 var num = new Number() 这种没有值的数字也归为 NaN</span></div><div class="line">  <span class="keyword">return</span> _.isNumber(obj) &amp;&amp; obj !== +obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>是否为undefined</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">_.isUndefined = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="comment">// 一般我们都用 if(obj) 来直接判断undefined</span></div><div class="line">  <span class="comment">// undefined 只是全局对象的一个属性，在局部环境能被重新定义</span></div><div class="line">  <span class="comment">// 但是 void 0 始终是 undefined</span></div><div class="line">  <span class="keyword">return</span> obj === <span class="keyword">void</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>是否有has指定key</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_.has = <span class="function"><span class="keyword">function</span>(<span class="params">obj, key</span>) </span>&#123;</div><div class="line">    <span class="comment">// obj 不能为 null 或者 undefined</span></div><div class="line">    <span class="keyword">return</span> obj != <span class="literal">null</span> &amp;&amp; hasOwnProperty.call(obj, key);</div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
<p>参考自：<a href="http://www.kancloud.cn/digest/underscore-source/82316" target="_blank" rel="external">http://www.kancloud.cn/digest/underscore-source/82316</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/07/13/underscoreSourceCode/" class="archive-article-date">
  	<time datetime="2016-07-13T10:06:56.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-07-13</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/underscore/">underscore</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/函数封装/">函数封装</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据判断/">数据判断</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-nodejsSync" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/09/nodejsSync/">node.js同步获取request请求内容</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;nodejs的异步执行给我们的编程带来了数不尽的好处，以至于我已经习惯了异步编程，某一次在执行request请求想要将其返回的body内容体传到request函数外时，发现怎么也获取不了，由于对node理解的不够深入透彻，我首先怀疑的竟然是<strong>会不会request不支持返回操作 or 难道操作仅在函数作用域内有效</strong>，后来才搞明白是异步执行惹的事儿，取值那会儿其实还没赋值呢。现在想想自己还是too naive..</p>
<p>&emsp;搞明白了是异步的问题之后，便想着如何把异步执行变同步执行，实现的方法有很多，我用的是Promise来实现。具体例子如下：</p>
<p>&emsp;简单地请求一下github并输出状态码 = =</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> request =  <span class="built_in">require</span>(<span class="string">'request'</span>);</div><div class="line"><span class="keyword">let</span> test = <span class="string">'I am test'</span>;</div><div class="line"></div><div class="line"><span class="comment">// async</span></div><div class="line">request(&#123;</div><div class="line">    <span class="attr">url</span>: <span class="string">'https://github.com'</span>,</div><div class="line">    <span class="attr">method</span>: <span class="string">'get'</span></div><div class="line">&#125;, (err, res, body) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (res &amp;&amp; res.statusCode === <span class="number">200</span>) &#123;</div><div class="line">      test = res.statusCode + <span class="string">'ok!'</span>;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'inside request: '</span> + test);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      test = <span class="string">'error - -'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'outside request: '</span> + test);</div></pre></td></tr></table></figure>
<p>&emsp;执行结果如下：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">node</span> <span class="title">request</span>.js</div><div class="line">outside request: I am test</div><div class="line">inside request: <span class="number">200</span> ok!</div></pre></td></tr></table></figure></p>
<p>&emsp;其实单从结果就可以看到，outside的执行是先于inside的，但是懵逼的我当时并没有发现，oops..</p>
<p>&emsp;言归正传，用上了Promise之后的画风是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span></div><div class="line"><span class="keyword">let</span> test = <span class="string">'I am test'</span>;</div><div class="line"><span class="keyword">let</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</div><div class="line"></div><div class="line"><span class="comment">// sync</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    request(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'https://github.com'</span>,</div><div class="line">        <span class="attr">method</span>: <span class="string">'get'</span></div><div class="line">    &#125;, (err, res, body) =&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (res &amp;&amp; res.statusCode === <span class="number">200</span>) &#123;</div><div class="line">            resolve(res.statusCode + <span class="string">' ok!'</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            reject(<span class="string">' error - -'</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</div><div class="line">    test = result;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"outside request: "</span> + test);</div><div class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"error: "</span> + err)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>&emsp;执行结果：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">node</span> <span class="title">request</span>.js</div><div class="line">outside request: <span class="number">200</span> ok!</div></pre></td></tr></table></figure></p>
<p>&emsp;这样一来，就能实现在request外也获取其内容的功能啦~~只要把代码都丢到then里面就可以了。</p>
<p>&emsp;好吧，写完之后发现，这他喵的这么简单我怎么会折腾这么久！ T T</p>
<p>&emsp;最后的最后，想告诫自己</p>
<blockquote>
<p>前端路阻且长，且行且珍惜。</p>
</blockquote>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/07/09/nodejsSync/" class="archive-article-date">
  	<time datetime="2016-07-09T12:19:06.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-07-09</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Promise/">Promise</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nodejs/">nodejs</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/request/">request</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/同步/">同步</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步/">异步</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 四月
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/ECMAScript/" style="font-size: 10px;">ECMAScript</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/Vue/" style="font-size: 20px;">Vue</a> <a href="/tags/Vuex/" style="font-size: 10px;">Vuex</a> <a href="/tags/actions/" style="font-size: 10px;">actions</a> <a href="/tags/apply/" style="font-size: 10px;">apply</a> <a href="/tags/bind/" style="font-size: 20px;">bind</a> <a href="/tags/call/" style="font-size: 10px;">call</a> <a href="/tags/es2015/" style="font-size: 10px;">es2015</a> <a href="/tags/es6/" style="font-size: 10px;">es6</a> <a href="/tags/es7/" style="font-size: 10px;">es7</a> <a href="/tags/getters/" style="font-size: 10px;">getters</a> <a href="/tags/javascript/" style="font-size: 20px;">javascript</a> <a href="/tags/modules/" style="font-size: 10px;">modules</a> <a href="/tags/mutations/" style="font-size: 10px;">mutations</a> <a href="/tags/nodejs/" style="font-size: 20px;">nodejs</a> <a href="/tags/request/" style="font-size: 10px;">request</a> <a href="/tags/state/" style="font-size: 10px;">state</a> <a href="/tags/this/" style="font-size: 10px;">this</a> <a href="/tags/underscore/" style="font-size: 10px;">underscore</a> <a href="/tags/vuejs/" style="font-size: 10px;">vuejs</a> <a href="/tags/入门/" style="font-size: 10px;">入门</a> <a href="/tags/全选/" style="font-size: 10px;">全选</a> <a href="/tags/函数封装/" style="font-size: 10px;">函数封装</a> <a href="/tags/分页/" style="font-size: 10px;">分页</a> <a href="/tags/同步/" style="font-size: 10px;">同步</a> <a href="/tags/异步/" style="font-size: 10px;">异步</a> <a href="/tags/搜索/" style="font-size: 10px;">搜索</a> <a href="/tags/数据判断/" style="font-size: 10px;">数据判断</a> <a href="/tags/源码/" style="font-size: 10px;">源码</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">我说我萌萌哒&lt;br&gt;你信吗？</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>