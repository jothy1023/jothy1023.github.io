<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Jothy AdoreLife..</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="人生总是失去之后才懂得珍惜，时间总是被荒废之后才明白要抓牢">
<meta property="og:type" content="website">
<meta property="og:title" content="Jothy AdoreLife..">
<meta property="og:url" content="https://jothy1023.github.io/index.html">
<meta property="og:site_name" content="Jothy AdoreLife..">
<meta property="og:description" content="人生总是失去之后才懂得珍惜，时间总是被荒废之后才明白要抓牢">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jothy AdoreLife..">
<meta name="twitter:description" content="人生总是失去之后才懂得珍惜，时间总是被荒废之后才明白要抓牢">
  
    <link rel="alternative" href="/atom.xml" title="Jothy AdoreLife.." type="application/atom+xml">
  
  
    <link rel="icon" href="/./favicon.ico">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="https://jothy1023.github.io/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">四月</a></h1>
		</hgroup>

		
		<p class="header-subtitle">人间四月芳菲尽，山寺桃花始盛开</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页菌</a></li>
	        
				<li><a href="/nodeJS">NodeJS</a></li>
	        
				<li><a href="/essay">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">Articles </a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)"> Tags </a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)"> Me</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/jothy1023" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/jothy1023" title="weibo">weibo</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">四月</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="https://jothy1023.github.io/avatar.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">四月</h1>
			</hgroup>
			
			<p class="header-subtitle">人间四月芳菲尽，山寺桃花始盛开</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页菌</a></li>
		        
					<li><a href="/nodeJS">NodeJS</a></li>
		        
					<li><a href="/essay">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/jothy1023" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/jothy1023" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-index" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/31/index/">Vuex 入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Vuex-是一个专门为-Vue-js-应用所设计的集中式状态管理架构"><a href="#Vuex-是一个专门为-Vue-js-应用所设计的集中式状态管理架构" class="headerlink" title="Vuex 是一个专门为 Vue.js 应用所设计的集中式状态管理架构 ."></a>Vuex 是一个专门为 Vue.js 应用所设计的集中式状态管理架构 .</h3><p>背景：小型应用里的每个组件维护着自有的状态，即当前应用的状态的一部分，所以整个应用的状态被分散在了各个角落，但是我们经常遇到要把<strong>状态的一部分</strong>共享给多个组件的情况。</p>
<blockquote>
<p>状态其实可以形象地想成我们的 data 里面的各个属性。</p>
</blockquote>
<hr>
<h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>Vuex 使用了单状态树（single state tree），一个 store 对象就存储了整个应用层的状态。它让我们可以更方便地定位某一具体的状态，并且在调试时能简单地获取到当前整个应用的快照。 </p>
<ul>
<li>先埋个伏笔。Vuex 使用的这种 single state tree 与 modularity 模块化是不冲突的，问题是，如何将 state 与 mutation 分到子模块中？</li>
<li>要使用 store ，首先必须<code>Vue.user(Vuex)</code>，然后将 store <code>const store = new Vuex.store()</code> inject 定义到 Vue 实例 app 中<code>new Vue({store})</code>，实现从根组件注入到所有子组件中，接着就可以在子组件中使用 <code>this.$store</code> 调用了。</li>
<li>当一个组件需要使用多个某 store 的状态属性或 getters ，可以使用 shared helper —— 共享帮手 <code>mapState</code>，它会返回一个对象 。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'helper: mapState (object)'</span>, () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">    <span class="attr">state</span>: &#123;</div><div class="line">      <span class="attr">a</span>: <span class="number">1</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getters</span>: &#123;</div><div class="line">      <span class="attr">b</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">2</span></div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">    store,</div><div class="line">    <span class="attr">computed</span>: mapState(&#123;</div><div class="line">      <span class="comment">// 在 mapState 里面我们既可以调用 store 的 state ，也可以调用 store 的 getters</span></div><div class="line">      a: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> state.a + getters.b</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">  expect(vm.a).toBe(<span class="number">3</span>)</div><div class="line">  store.state.a++</div><div class="line">  expect(vm.a).toBe(<span class="number">4</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>那么如何将它与本地的计算属性结合使用呢？一般我们会使用一个工具，将多个对象合而为一，再把这个最终的对象传递给 computed。但是这里我们可以直接使用 es6 的 stage 3 的 object spread operator —— 对象扩展操作符，来超简洁地实现这一功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">  localComputed () &#123;&#125;</div><div class="line">  <span class="comment">// 将其中的属性与本地的计算属性合并在一起</span></div><div class="line">  ...mapState(&#123;</div><div class="line">    <span class="attr">message</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.obj.message</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h4><p>  有时候我们需要从 store 的状态派生出其他状态，然后对这个状态（的方法）在多个组件中加以利用。通常我们的做法是复制这个方法，或者将它封装为一个公用的方法，然后在需要的时候导入，但是两者其实都不甚理想。Vuex 提供了 getters 属性，用途类似 stores 中的计算属性。<br>  getters 中的方法接受两个参数，分别为 state 以及 getters（其他 getters），用法如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">getters: &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  doneTodosCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> getters.doneTodos.length</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么我们在其他组件内部使用 getters 也变得十分简单</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">  doneTodosCount () &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doneTodosCount</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>mapGetters<br>可以将 store 的 getters 映射到本地的计算属性中来，除了可以使用数组之外，还可以使用对象起别名。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">...mapGetters([</div><div class="line">  <span class="string">'doneTodosCount'</span>,</div><div class="line">  <span class="string">'anotherGetter'</span>,</div><div class="line">  <span class="comment">// ...</span></div><div class="line">])</div></pre></td></tr></table></figure>
<hr>
<h4 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h4><p>能改变 Vuex store 中的 state 状态的唯一方法是提交 mutation 变更。mutation 和事件很像：都有字符串类型的 type 以及 handler 句柄。我们在 handler 中实际修改 state，state 为每个 mutation 的第一个参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="attr">state</span>: &#123;</div><div class="line">    <span class="attr">count</span>: <span class="number">1</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123;</div><div class="line">    increment (state) &#123;</div><div class="line">      <span class="comment">// mutate state</span></div><div class="line">      state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// call， 只有在使用 type increment 调用 mutation 时才能称为 handler</span></div><div class="line">store.commit(<span class="string">'increment'</span>)</div></pre></td></tr></table></figure>
<p>commit 的第二个可选参数为 payload 有效载荷，可以为普通类型或对象类型等等。<br>commit 方法还可以通过对象形式调用，这种情况下，这个对象都会被当成 payload 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">store.commit(&#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">'increment'</span>,</div><div class="line">  <span class="attr">amount</span>: <span class="number">10</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>little tips</li>
</ul>
<ul>
<li>建议使用大写命名 Mutation<br>将所有大写变量存放在一个文件中，需要的时候引入。使用 es6 的计算属性名新特性来使用常量作为方法名。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// mutation-types.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> SOME_MUTATION = <span class="string">'SOME_MUTATION'</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// store.js</span></div><div class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"><span class="keyword">import</span> &#123; SOME_MUTATION &#125; <span class="keyword">from</span> <span class="string">'./mutation-types'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="attr">state</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123;</div><div class="line">    <span class="comment">// we can use the ES2015 computed property name feature</span></div><div class="line">    <span class="comment">// to use a constant as the function name</span></div><div class="line">    [SOME_MUTATION] (state) &#123;</div><div class="line">      <span class="comment">// mutate state</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<blockquote>
<p>es6 计算属性名</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// e.g: 使用含有空格的变量作为属性名会报错，此时可以将它存为字符串或者存在中括号包裹的变量中</span></div><div class="line"><span class="keyword">var</span> lastName = <span class="string">"last name"</span>;</div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="string">"first name"</span>: <span class="string">"Nicholas"</span>,</div><div class="line">    <span class="comment">// 中括号包裹的变量</span></div><div class="line">    [lastName]: <span class="string">"Zakas"</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(person[<span class="string">"last name"</span>]); <span class="comment">// Zakas</span></div></pre></td></tr></table></figure>
<ul>
<li>mutations 必须都是同步的，它的改变必须在调用之后立即执行<br>因为它是唯一可以修改 state 的，如果它使用了异步方法，将会使我们的 state 变得无法追踪，定位问题也变得是否困难</li>
<li>在组件中 commit mutation 时<br>可以使用 this.$store.commit() 或者使用 mapMutations 方法，后者可以将组件中的方法映射到 store.commit 调用（需要在根组件注入 store）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  methods: &#123;</div><div class="line">    <span class="comment">// 传入数组</span></div><div class="line">    ...mapMutations([</div><div class="line">      <span class="string">'increment'</span> <span class="comment">// map this.increment() to this.$store.commit('increment')</span></div><div class="line">    ]),</div><div class="line">    <span class="comment">// 传入对象，可以使用 alias</span></div><div class="line">    ...mapMutations(&#123;</div><div class="line">      <span class="attr">add</span>: <span class="string">'increment'</span> <span class="comment">// map this.add() to this.$store.commit('increment')</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h4><p>actions 是提交 mutations 的，它可以有任意的异步操作。<br>actions 的第一个参数是 context，它向外暴露一组与 store 实例相同的方法/属性，所以可以直接调用 context.commit 或者访问 context.state 或者 context.getters 。我们通常使用 es6 的参数解构来简化我们的代码，直接写成 <code>{ commit }</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">  increment (&#123; commit &#125;) &#123;</div><div class="line">    commit(<span class="string">'increment'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如何触发 Actions？<br>actions 通过<code>store.dispatch(&#39;actionName&#39;)</code> 触发，其方法体中再触发 mutation，但是 mutations 是可以直接通过 store.commit 触发的，那么为什么不直接使用 store.commit(‘mutationName’) 呢？因为，actions 是可以异步执行的，而 mutations 只可以同步。所以这种 dispatch 调用可以在 action 内执行异步操作，也就是说可以执行异步 mutation。</li>
</ul>
<ul>
<li>可以使用 payload 格式或者对象形式触发。二者等价</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// dispatch with a payload</span></div><div class="line">store.dispatch(<span class="string">'incrementAsync'</span>, &#123;</div><div class="line">  <span class="attr">amount</span>: <span class="number">10</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// dispatch with an object</span></div><div class="line">store.dispatch(&#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">'incrementAsync'</span>,</div><div class="line">  <span class="attr">amount</span>: <span class="number">10</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>shopping cart 中的实际应用，既调用了异步 API，又提交了多个 mutation。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">  checkout (&#123; commit, state &#125;, payload) &#123;</div><div class="line">    <span class="comment">// save the items currently in the cart</span></div><div class="line">    <span class="keyword">const</span> savedCartItems = [...state.cart.added]</div><div class="line">    <span class="comment">// send out checkout request, and optimistically</span></div><div class="line">    <span class="comment">// clear the cart</span></div><div class="line">    commit(types.CHECKOUT_REQUEST)</div><div class="line">    <span class="comment">// the 异步 shop API accepts a success callback and a failure callback</span></div><div class="line">    shop.buyProducts(</div><div class="line">      products,</div><div class="line">      <span class="comment">// handle success</span></div><div class="line">      () =&gt; commit(types.CHECKOUT_SUCCESS),</div><div class="line">      <span class="comment">// handle failure</span></div><div class="line">      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在组件中分发 Actions<br>可以使用 <code>this.$store.dispatch()</code> 或者 <code>mapActions</code> 映射组件方法到 <code>store.dispatch</code> 中调用（需要注入 root）。同 <code>mapMutations</code></li>
<li>Actions 组合，怎么控制 actions 执行呢？<br>由于 actions 是异步的，因此我们就很难知道一个 action 什么时候完成，以及该怎么把多个 action 组合起来，处理复杂的异步工作流？<br>好在， <code>store.dispatch()</code> 方法返回了我们定义的 action handler 的返回值，所以我们可以直接返回一个 Promise 呀~</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">  actionA (&#123; commit &#125;) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        commit(<span class="string">'someMutation'</span>)</div><div class="line">        resolve()</div><div class="line">      &#125;, <span class="number">1000</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以这么用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>然后在另一个 action 中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</div><div class="line">    <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      commit(<span class="string">'someOtherMutation'</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h4><p>由于 Vuex 使用了单状态树，所以随着我们应用的规模逐渐增大， store 也越来越膨胀。为了应对这个问题，Vuex 允许我们将 store 分成多个 modules。每个 module 有着自己的 state, mutations, actions, getters, 甚至可以有嵌套（ nested ）的 modules。比如说：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  <span class="attr">state</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">getters</span>: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> moduleB = &#123;</div><div class="line">  <span class="attr">state</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">actions</span>: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="attr">modules</span>: &#123;</div><div class="line">    <span class="attr">a</span>: moduleA,</div><div class="line">    <span class="attr">b</span>: moduleB</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 注意，调用的时候，多个模块都在 state 对象中，而非 modules 中</span></div><div class="line">store.state.a <span class="comment">// -&gt; moduleA's state</span></div><div class="line">store.state.b <span class="comment">// -&gt; moduleB's state</span></div></pre></td></tr></table></figure>
<ul>
<li>modules 中的各种 state ， local or root？<ul>
<li>mutations 和 getters 中，接受的第一个参数是 modules 的本地 state</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  <span class="attr">state</span>: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123;</div><div class="line">    <span class="attr">increment</span>: (state) &#123;</div><div class="line">      <span class="comment">// state is the local module state</span></div><div class="line">      state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">getters</span>: &#123;</div><div class="line">    doubleCount (state) &#123;</div><div class="line">      <span class="keyword">return</span> state.count * <span class="number">2</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li></li>
</ul>
<ul>
<li>相似地，在 actions 中，<code>context.state</code> 为本地 state，而 <code>context.rootState</code> 为根 state</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  actions: &#123;</div><div class="line">    incrementIfOdd (&#123; state, commit &#125;) &#123;</div><div class="line">      <span class="keyword">if</span> (state.count % <span class="number">2</span> === <span class="number">1</span>) &#123;</div><div class="line">        commit(<span class="string">'increment'</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li></li>
</ul>
<ul>
<li>getters 的第三个参数才是 root state</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  getters: &#123;</div><div class="line">    sumWithRootCount (state, getters, rootState) &#123;</div><div class="line">      <span class="keyword">return</span> state.count + rootState.count</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="Strict-Mode-amp-Form-Handling"><a href="#Strict-Mode-amp-Form-Handling" class="headerlink" title="Strict Mode &amp; Form Handling"></a>Strict Mode &amp; Form Handling</h4><p>严格模式下，如果在 mutation handler 之外修改了 Vuex 的 state，应用就会抛错。比如我们将 Vuex 中的某个数据，用 Vue 的 v-model 绑定到 input 时，一旦感应到 input 改动，就会尝试去直接修改这个数据，严格模式下就会报错。所以建议是绑定 value 值，然后在 input 时调用 action 。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">"message"</span> @<span class="attr">input</span>=<span class="string">"updateMessage"</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line">computed: &#123;</div><div class="line">  ...mapState(&#123;</div><div class="line">    <span class="attr">message</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.obj.message</div><div class="line">  &#125;)</div><div class="line">&#125;,</div><div class="line"><span class="attr">methods</span>: &#123;</div><div class="line">  updateMessage (e) &#123;</div><div class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'updateMessage'</span>, e.target.value)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>mutation 可以这么处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mutations: &#123;</div><div class="line">  updateMessage (state, message) &#123;</div><div class="line">    state.obj.message = message</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>诚然，这样做是很仔细明了的，但是我们也不能用 v-model 这么好用的方法了，另外一个方法就是继续使用 v-model ，并配套使用 双向计算属性和 setter 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">  <span class="attr">message</span>: &#123;</div><div class="line">    get () &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.obj.message</div><div class="line">    &#125;,</div><div class="line">    set (value) &#123;</div><div class="line">      <span class="comment">// 直接 commit 到 mutation，type 为 updateMessage</span></div><div class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'updateMessage'</span>, value)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>建议部署到开发环境的时候一定一定要关掉严格模式。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/08/31/index/" class="archive-article-date">
  	<time datetime="2016-08-31T05:17:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-08-31</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/">Vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vuex/">Vuex</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/actions/">actions</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/getters/">getters</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/modules/">modules</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mutations/">mutations</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/state/">state</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/入门/">入门</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-thisInJS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/28/thisInJS/">javascript中函数的this指向以及apply/call/bind函数的联系与区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p>&emsp; 三者的联系就在于，都可以用来改变函数中 this 指向的值，且第一个参数为要指向的 this 的值，apply的第二个参数（或 bind 与 call 的不定参数）为要传入的参数。这就不得不提及 javascript 中函数的 this 的指向了。this 的指向大概有以下几种。</p>
<p>1.全局作用域下或正常的函数调用的 this<br>此时 this 指向的是全局对象。这时有两种情况，如果是在浏览器环境下运行，则 this 指向全局的 window 对象；而如果是在 nodejs 环境下执行，命令行中指向的是 global 对象。有一点需要注意的是，严格模式 “use strict” 下的 this 为 undefined 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 浏览器</span></div><div class="line"><span class="keyword">this</span>.a = <span class="number">10</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 10</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// nodejs</span></div><div class="line"><span class="keyword">this</span>.a = <span class="number">20</span>;</div><div class="line"><span class="built_in">console</span>.log(global.a); <span class="comment">// 20</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 非严格模式</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(f1() === <span class="built_in">window</span>); <span class="comment">// 浏览器 true</span></div><div class="line"><span class="built_in">console</span>.log(f1() === global); <span class="comment">// nodejs true</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 严格模式下</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">  "use strict"</span>;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(f2() === <span class="literal">undefined</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>2.当函数作为某对象的方法被调用时<br> this 指向的是调用该函数的对象，以下代码指的是对象 a。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">  <span class="attr">b</span>: <span class="number">30</span>,</div><div class="line">  <span class="attr">c</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.b);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">a.c(); <span class="comment">// 30</span></div></pre></td></tr></table></figure>
<p>3.构造器函数调用<br>以构造器函数的形式声明函数，再用 new 关键字声明一个新的函数对象，此时函数中的 this 指向这个构造出来的对象。在 jslint 比较严格的要求下，这种构造函数的函数名必须是首字母大写的形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.b = <span class="number">40</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> A();</div><div class="line"><span class="built_in">console</span>.log(obj.b); <span class="comment">// 40</span></div></pre></td></tr></table></figure>
<p>4.利用 apply/call/bind 方法强制改变 this 的指向<br>这时可以将要指向的对象 O 作为第一个参数传给以上任意三个函数之一，用某 F 函数调用这三个函数，这样 F 函数中的所有 this 的指向就都变成了对象 O，并且此时 O 就算没有声明 F 函数中的方法，也可以正常调用 F 函数中的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.b + arg);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">b</span> : <span class="number">1</span></div><div class="line">&#125;;</div><div class="line">a(); <span class="comment">// NaN</span></div><div class="line">a.apply(obj, [<span class="number">50</span>]); <span class="comment">// 51</span></div><div class="line">a.call(obj, <span class="number">60</span>); <span class="comment">// 61</span></div><div class="line"><span class="keyword">var</span> c = a.bind(obj, <span class="number">70</span>);</div><div class="line">c(); <span class="comment">// 71</span></div></pre></td></tr></table></figure>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>其实区别从上面的第四种也可见一斑。</p>
<ol>
<li>apply 与 call： 第二个参数的形式 apply 为数组形式，函数会自动帮我们把数组展开，而 call 与 bind 为不定参数，需要传递几个就传递几个。</li>
<li>bind 与 （apply 和 call）：apply 与 call 都是在被调用的时候就执行函数体内容，而 bind 绑定之后返回绑定完成的函数，需要再显式执行一次此函数才能完成调用。</li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/07/28/thisInJS/" class="archive-article-date">
  	<time datetime="2016-07-28T02:36:09.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-07-28</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/apply/">apply</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/bind/">bind</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/call/">call</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nodejs/">nodejs</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/this/">this</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-underscoreSourceCode" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/13/underscoreSourceCode/">underscore源码解析之类型判断函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;首先将内置对象的原型链以及内置对象原型中的常用方法缓存在局部变量中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 内置对象原型链</span></div><div class="line"><span class="keyword">var</span> ArrayProto = <span class="built_in">Array</span>.prototype,</div><div class="line">    ObjProto = <span class="built_in">Object</span>.prototype,</div><div class="line">    FuncProto = <span class="built_in">Function</span>.prototype;</div><div class="line"></div><div class="line"><span class="comment">// 内置对象原型中的常用方法 e.g: toString</span></div><div class="line"><span class="keyword">var</span> toString = ObjProto.toString,</div><div class="line">    hasOwnProperty = ObjProto.hasOwnProperty;</div></pre></td></tr></table></figure>
<p>&emsp;这样做的好处除了简洁代码之外，还有两个好处，首先是利于代码的压缩。而原生的对象原型无法进行压缩，e.g: Object.Protype压缩之后宿主就不认识了，但是objProto可以压缩为a，之后的调用也可以正常进行；然后是可减少在原型链中的查找次数(提高代码效率)。</p>
<hr>
<p>&emsp;再定义一组javascript原生支持的判断函数，若宿主环境（浏览器/nodejs）支持，则直接返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> nativeIsArray      = <span class="built_in">Array</span>.isArray,</div><div class="line">    nativeKeys         = <span class="built_in">Object</span>.keys,</div><div class="line">    nativeBind         = FuncProto.bind,</div><div class="line">    nativeCreate       = <span class="built_in">Object</span>.create;</div></pre></td></tr></table></figure>
<p>&emsp;若不支持以上函数（es5之后才支持），则返回underscore自己写的判断函数。</p>
<hr>
<ul>
<li>是否为DOM</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_.isElement = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="comment">// 首先确保不是 null/undefined 等假值（!!obj），</span></div><div class="line">  <span class="comment">// DOM 的 nodeType 为1，!!用于强制类型转换为 Boolean 值</span></div><div class="line">  <span class="keyword">return</span> !!(obj &amp;&amp; obj.nodeType === <span class="number">1</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>是否为数组Array</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_.isArray = nativeIsArray || <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="comment">// call 方法可以使得任意 obj 都可以调用 toString 方法，即使是没有 toString 方法的对象</span></div><div class="line">  <span class="keyword">return</span> toString.call(obj) === <span class="string">'[object aray]'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>是否为对象Object</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">_.isObject = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> type = <span class="keyword">typeof</span>(obj);</div><div class="line">  <span class="comment">// 除了普通对象之外，函数也是对象</span></div><div class="line">  <span class="comment">// !!obj 是为了排除 null 的情况，因为 typeof null 也为 object</span></div><div class="line">  <span class="keyword">return</span> type === <span class="string">'function'</span> || type === <span class="string">'object'</span> &amp;&amp; !!obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>是否为布尔值Boolean</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_.isBoolean = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="comment">// 除了 true 与 false 之外，布尔值还可能是 new Boolean() 哦</span></div><div class="line">  <span class="comment">// 不过似乎直接用最后一种判断就可以了？</span></div><div class="line">  <span class="keyword">return</span> obj === <span class="string">'true'</span> || obj === <span class="string">'false'</span> || toString.call(obj) === <span class="string">'[object boolean]'</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>是否为arguments</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!_.isArguments(<span class="built_in">arguments</span>)) &#123;</div><div class="line">  _.isArguments = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="comment">// 通过是否有 callee 方法判断</span></div><div class="line">    <span class="comment">// 因为IE &lt; 9 下对 arguments 调用 Object.prototype.toString.call 方法</span></div><div class="line">    <span class="comment">// 返回的是 [object Object] ，而非 [object Arguments]</span></div><div class="line">    <span class="keyword">return</span> _.has(obj, <span class="string">'callee'</span>);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>是否为NaN</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">_.isNaN = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="comment">// NaN是一个Number类型，但是它不等于它本身</span></div><div class="line">  <span class="comment">// ‘+’ 放在变量前面一般作用是把后面的变量变成一个数，</span></div><div class="line">  <span class="comment">// 在这里已经判断为一个数仍加上 ‘+’，是为了把 var num = new Number() 这种没有值的数字也归为 NaN</span></div><div class="line">  <span class="keyword">return</span> _.isNumber(obj) &amp;&amp; obj !== +obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>是否为undefined</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">_.isUndefined = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="comment">// 一般我们都用 if(obj) 来直接判断undefined</span></div><div class="line">  <span class="comment">// undefined 只是全局对象的一个属性，在局部环境能被重新定义</span></div><div class="line">  <span class="comment">// 但是 void 0 始终是 undefined</span></div><div class="line">  <span class="keyword">return</span> obj === <span class="keyword">void</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>是否有has指定key</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_.has = <span class="function"><span class="keyword">function</span>(<span class="params">obj, key</span>) </span>&#123;</div><div class="line">    <span class="comment">// obj 不能为 null 或者 undefined</span></div><div class="line">    <span class="keyword">return</span> obj != <span class="literal">null</span> &amp;&amp; hasOwnProperty.call(obj, key);</div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
<p>参考自：<a href="http://www.kancloud.cn/digest/underscore-source/82316" target="_blank" rel="external">http://www.kancloud.cn/digest/underscore-source/82316</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/07/13/underscoreSourceCode/" class="archive-article-date">
  	<time datetime="2016-07-13T10:06:56.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-07-13</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/underscore/">underscore</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/函数封装/">函数封装</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据判断/">数据判断</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 四月
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/Vuex/" style="font-size: 10px;">Vuex</a> <a href="/tags/actions/" style="font-size: 10px;">actions</a> <a href="/tags/apply/" style="font-size: 10px;">apply</a> <a href="/tags/bind/" style="font-size: 10px;">bind</a> <a href="/tags/call/" style="font-size: 10px;">call</a> <a href="/tags/getters/" style="font-size: 10px;">getters</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/modules/" style="font-size: 10px;">modules</a> <a href="/tags/mutations/" style="font-size: 10px;">mutations</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/state/" style="font-size: 10px;">state</a> <a href="/tags/this/" style="font-size: 10px;">this</a> <a href="/tags/underscore/" style="font-size: 10px;">underscore</a> <a href="/tags/入门/" style="font-size: 10px;">入门</a> <a href="/tags/函数封装/" style="font-size: 10px;">函数封装</a> <a href="/tags/数据判断/" style="font-size: 10px;">数据判断</a> <a href="/tags/源码/" style="font-size: 10px;">源码</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">我说我萌萌哒&lt;br&gt;你信吗？</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>