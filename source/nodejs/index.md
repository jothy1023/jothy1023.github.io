---
title: 超易懂！NodeJS异步I/O的实现过程
date: 2016-07-31 13:17:48
tag: [nodejs]
---

### 踩着七月的尾巴 ^ ^  

#### First of all

之前一提起 node 的异步 I/O ，总是脑海里有个大概的轮廓，但是描述出来的话需要比较大的篇幅，不够有条理，对于事件循环、单线程等的参与也没那么清晰，所以今天想理顺下整个过程，朴灵大大的《深入浅出NodeJS》讲得很详细很清楚，只不过对于我这种计算机底层基础不够扎实的人来说，还是需要翻成大白话比较好理解记忆。如果有说得不对的地方请帮忙指正。^^  
首先明确下，我们讨论的是从肉眼可见的 javascript 代码调用至内核执行完 I/O 操作到最终回调函数执行的过程。  

#### Process

大概的过程应该是这样子的：

1. 首先是 JS 代码发起异步调用，这时候会创建一个请求对象，我们姑且称为 R ， R 中封装了 JS 层传入的参数以及当前的方法，回调函数封装在 cocomplete_sym 属性上。
2. R 封装完毕后，就调用相关方法将 R 推入线程池中执行。（然后推进去之后咧，JS 线程就返回去继续阅读代码并且重复1-2的操作）
3. 接着我们来到线程池，刚刚 R 封装的 I/O 操作就在这儿等待执行，（无论它是否阻塞 I/O，我们的 JS 线程都已经回去啦～所以异步的目的 get！）
4. 然后 I/O 操作就依赖于相应操作系统执行啦～执行完成后，结果会存储在 R 的 result 属性上，然后通知内核：我的操作已经完成啦！并把线程归还给线程池。
5. 这其实与上一个步骤没有绝对的先后关系，而是同时执行的。伟大的事件循环就粗现在这儿啦！事件循环中专门负责检查时间状态的 I/O 观察者会检查线程池中是否有已完成的请求。若有，则取出它的 cocomplete_sym 属性作为方法，result 属性作为参数，加入到观察者的队列中。事件循环每次 Tick 检查队列，发现有事件就取出事件及其相关的回调函数并执行它，也就达到了调用前面传入的回调函数的目的，回调函数最终还是回到 JS 线程中执行。

#### Know More

1. 关于单、多线程：我们常说的 NodeJS 的单线程其实指的是 node 保留了 javascript 在浏览器中的单线程特点。只有 JS 是单线程的，所以从 JS 发起调用到将请求对象推入线程池的过程不是并行的；而 node 本身是多线程的，所以才能在线程池中多线程并行执行 I/O 操作。
2. 不同操作系统的实现：Windows 下的线程池由内核（IOCP）提供，因此推入线程池及取出已完成 I/O 操作都要由 IOCP 完成；而 \*nix 下，线程池直接就由 libuv 实现，相应的过程由 epoll 完成。
3. 关于事件循环：事件循环其实就类似一个 while 循环，每一次循环是一个 Tick，每个 Tick 观察者都会检查是否队列中是否有事件，有的话就取出事件及其相应的回调函数并执行。事件循环除了可以处理以上的异步 I/O 之外，也可以处理 node 中其他异步非 I/O 的 API。原理相同，只是少了 I/O 操作相关的步骤而已。
4. 事件驱动：也就是以主循环+事件触发的方式运行程序。即前面的事件循环与观察者检查是否已完成，并将已完成的加入队列，等待事件循环取出并处理的方式。
